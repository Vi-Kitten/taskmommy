use std::env;
use std::fs;
use std::io::{Read, Write, Error, ErrorKind};
use std::path::Path;
use std::time::SystemTime;
use tasks::*;

pub mod tasks;

struct ProcessMemory {
    selected_task_id: Option<TaskID>
}

impl ProcessMemory {
    fn new() -> ProcessMemory {
        ProcessMemory {
            selected_task_id: None
        }
    }

    fn try_parse_arg(&mut self, mut messages: Vec<String>, data: &mut Data, arg: &String) -> Result<Vec<String>, Error> {
        Ok(false)
        .and_then(|done| self.try_parse_new_task(&mut messages, data, arg, done))
        .and_then(|done| self.try_parse_select_task(&mut messages, data, arg, done))
        .and_then(|done| self.try_parse_display_task(&mut messages, data, arg, done))
        .and_then(|done| {
            if done {
                Ok(messages)
            } else {
                Err(Error::new(ErrorKind::InvalidInput, format!("flag '{}' not recognised", arg)))
            }
        })
    }

    fn try_parse_new_task(&mut self, messages: &mut Vec<String>, data: &mut Data, arg: &String, done: bool) -> Result<bool, Error> {
        if done { return Ok(done) }
        let Some(rest) = arg.strip_prefix("new") else {
            return Ok(false)
        };
        let new_task = if rest == "" {
            tasks::Task::new()
        } else {
            let Some(mut base_id) = rest.strip_prefix("=") else {
                return Err(Error::new(ErrorKind::InvalidInput, format!("expected = or nothing after -n, found {:?}", rest)))
            };
            if base_id == "select" {
                let Some(new_base_id) = &self.selected_task_id else {
                    return Err(Error::new(ErrorKind::InvalidInput, format!("no selected task for template")))
                };
                base_id = new_base_id;
            }
            let Some(base) = data.tasks.get(&base_id.to_lowercase()) else {
                return Err(Error::new(ErrorKind::NotFound, format!("no task with id '{}' could be found", base_id)))
            };
            tasks::Task {
                time_created: SystemTime::now(),
                base: Some(format!("{}", base_id)),
                tags: base.tags.clone(),
                name: base.name.clone(),
                logs: vec![]
            }
        };

        data.tasks_created += 1;
        /*
            the key is generated by multiplying the counter value
            by the fractional component of the golden ratio scaled by max u32
            that is rounded to the nearest odd number to ensure it is coprime with max u32.
            this makes the key feel random
        */ 
        let id = format!("{:08x}", data.tasks_created.wrapping_mul(2654435769));
        data.tasks.insert(id.clone(), new_task);
        messages.push(format!("task created with id: {}", id));
        self.selected_task_id = Some(id);
        Ok(true)
        
    }

    fn try_parse_select_task(&mut self, _messages: &mut Vec<String>, data: &mut Data, arg: &String, done: bool) -> Result<bool, Error> {
        if done { return Ok(done) }
        let Some(task_id) = arg.strip_prefix("select=") else {
            return Ok(false)
        };
        if !data.tasks.contains_key(&task_id.to_lowercase()) {
            return Err(Error::new(ErrorKind::NotFound, format!("no task with id '{}' could be found", task_id)))
        }
        self.selected_task_id = Some(format!("{}", task_id));
        Ok(true)
    }

    fn try_parse_display_task(&mut self, messages: &mut Vec<String>, data: &mut Data, arg: &String, done: bool) -> Result<bool, Error> {
        if done { return Ok(done) }
        if arg != "display" {
            return Ok(false)
        }
        let Some(task_id) = &self.selected_task_id else {
            return Err(Error::new(ErrorKind::InvalidInput, format!("no selected task for displaying")))
        };
        messages.push(format!("{:?}", data.tasks[task_id]));
        Ok(true)
    }
}

fn main() -> Result<(), Error> {
    let args: Vec<String> = env::args().collect();

    let mut iter_args = args.iter();

    let _app_location = iter_args.next().unwrap();

    let Some(path_str) = iter_args.next() else {
        return Err(Error::new(ErrorKind::InvalidInput, "please provide a file path"))
    };

    let tmp_path_str = format!("{}.tmp", path_str);

    let path = Path::new(path_str);
    let tmp_path = Path::new(&tmp_path_str);

    let mut data: Data = if path.exists() {
        let mut file = fs::File::options().read(true).open(path)?;
    
        let mut content = String::new();
        file.read_to_string(&mut content)?;
    
        serde_json::from_str(&content)?
    } else {
        tasks::Data::new()
    };

    let mut process_memory = ProcessMemory::new();

    iter_args.try_fold(
        vec![],
        |messages, arg| process_memory.try_parse_arg(messages, &mut data, arg)
    )?.into_iter().for_each(|message| println!("{}", message));

    let mut tmp_file = fs::File::options().write(true).create_new(true).open(tmp_path)?;

    tmp_file.write_all(serde_json::to_string(&data).unwrap().as_bytes()).and_then(|_| {
        std::fs::rename(&tmp_path, &path)
    }).map_err(|e| {
        drop(tmp_file);
        if let Err(error) = fs::remove_file(tmp_path_str.clone()) {
            eprintln!("failure to delete {}: {}", tmp_path_str, error)
        };
        e
    })?;

    Ok(())
}
